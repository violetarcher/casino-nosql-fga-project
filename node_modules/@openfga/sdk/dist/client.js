"use strict";
/**
 * JavaScript and Node.js SDK for OpenFGA
 *
 * API version: 0.1
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/js-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenFgaClient = exports.ClientWriteStatus = void 0;
const asyncPool = require("tiny-async-pool");
const api_1 = require("./api");
const base_1 = require("./base");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const validation_1 = require("./validation");
const DEFAULT_MAX_METHOD_PARALLEL_REQS = 10;
const CLIENT_METHOD_HEADER = "X-OpenFGA-Client-Method";
const CLIENT_BULK_REQUEST_ID_HEADER = "X-OpenFGA-Client-Bulk-Request-Id";
var ClientWriteStatus;
(function (ClientWriteStatus) {
    ClientWriteStatus["SUCCESS"] = "success";
    ClientWriteStatus["FAILURE"] = "failure";
})(ClientWriteStatus || (exports.ClientWriteStatus = ClientWriteStatus = {}));
class OpenFgaClient extends base_1.BaseAPI {
    constructor(configuration, axios) {
        super(configuration, axios);
        this.axios = axios;
        this.api = new api_1.OpenFgaApi(this.configuration, axios);
        this.authorizationModelId = configuration.authorizationModelId;
        this.getAuthorizationModelId(); // validates the authorization model id
    }
    getAuthorizationModelId(options = {}) {
        const authorizationModelId = (options === null || options === void 0 ? void 0 : options.authorizationModelId) || this.authorizationModelId;
        if (authorizationModelId && !(0, validation_1.isWellFormedUlidString)(authorizationModelId)) {
            throw new errors_1.FgaValidationError("authorizationModelId");
        }
        return authorizationModelId;
    }
    /**
     * checkValidApiConnection - Ensures that the credentials are valid for calling the API
     * If the authorization model id is available, this will attempt to get that model
     * Otherwise this will attempt to get the latest authorization model
     * @param {ClientRequestOptsWithAuthZModelId} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    checkValidApiConnection() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            if (this.getAuthorizationModelId(options)) {
                yield this.readAuthorizationModel(options);
            }
            else {
                yield this.readLatestAuthorizationModel(options);
            }
        });
    }
    /**********
     * Stores *
     **********/
    /**
     * ListStores - Get a paginated list of stores.
     * @summary List all stores
     * @param {ClientRequestOpts & PaginationOptions} [options]
     * @param {number} [options.pageSize]
     * @param {string} [options.continuationToken]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     * @throws { FgaError }
     */
    listStores() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            return this.api.listStores(options.pageSize, options.continuationToken, options);
        });
    }
    /**
     * CreateStore - Initialize a store
     * @param {CreateStoreRequest} body
     * @param {ClientRequestOpts} [options]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    createStore(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = {}) {
            return this.api.createStore(body, options);
        });
    }
    /**
     * GetStore - Get information about the current store
     * @param {ClientRequestOpts} [options]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    getStore() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            return this.api.getStore(options);
        });
    }
    /**
     * DeleteStore - Delete a store
     * @param {ClientRequestOpts} [options]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    deleteStore() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            return this.api.deleteStore(options);
        });
    }
    /************************
     * Authorization Models *
     ************************/
    /**
     * ReadAuthorizationModels - Read all authorization models
     * @param {ClientRequestOpts & PaginationOptions} [options]
     * @param {number} [options.pageSize]
     * @param {string} [options.continuationToken]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    readAuthorizationModels() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            return this.api.readAuthorizationModels(options.pageSize, options.continuationToken, options);
        });
    }
    /**
     * WriteAuthorizationModel - Create a new version of the authorization model
     * @param {WriteAuthorizationModelRequest} body
     * @param {ClientRequestOpts} [options]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    writeAuthorizationModel(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = {}) {
            return this.api.writeAuthorizationModel(body, options);
        });
    }
    /**
     * ReadAuthorizationModel - Read the current authorization model
     * @param {ClientRequestOptsWithAuthZModelId} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    readAuthorizationModel() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const authorizationModelId = this.getAuthorizationModelId(options);
            if (!authorizationModelId) {
                throw new errors_1.FgaRequiredParamError("ClientConfiguration", "authorizationModelId");
            }
            return this.api.readAuthorizationModel(authorizationModelId, options);
        });
    }
    /**
     * ReadLatestAuthorizationModel - Read the latest authorization model for the current store
     * @param {ClientRequestOpts} [options]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    readLatestAuthorizationModel() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            var _a;
            const { headers = {} } = options;
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_METHOD_HEADER, "ReadLatestAuthorizationModel");
            const authorizationModelsResponse = yield this.readAuthorizationModels(Object.assign(Object.assign({}, options), { pageSize: 1, headers }));
            const response = authorizationModelsResponse;
            response.authorization_model = (_a = authorizationModelsResponse.authorization_models) === null || _a === void 0 ? void 0 : _a[0];
            delete response.authorization_models;
            return response;
        });
    }
    /***********************
     * Relationship Tuples *
     ***********************/
    /**
     * Read Changes - Read the list of historical relationship tuple writes and deletes
     * @param {ClientReadChangesRequest} [body]
     * @param {ClientRequestOpts & PaginationOptions} [options]
     * @param {number} [options.pageSize]
     * @param {string} [options.continuationToken]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    readChanges(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = {}) {
            return this.api.readChanges(body === null || body === void 0 ? void 0 : body.type, options.pageSize, options.continuationToken, options);
        });
    }
    /**
     * Read - Read tuples previously written to the store (does not evaluate)
     * @param {ClientReadRequest} body
     * @param {ClientRequestOpts & PaginationOptions} [options]
     * @param {number} [options.pageSize]
     * @param {string} [options.continuationToken]
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    read() {
        return __awaiter(this, arguments, void 0, function* (body = {}, options = {}) {
            const readRequest = {
                page_size: options.pageSize,
                continuation_token: options.continuationToken,
            };
            if (body.user || body.object || body.relation) {
                readRequest.tuple_key = body;
            }
            return this.api.read(readRequest, options);
        });
    }
    /**
     * Write - Create or delete relationship tuples
     * @param {ClientWriteRequest} body
     * @param {ClientRequestOptsWithAuthZModelId & ClientWriteRequestOpts} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.transaction]
     * @param {boolean} [options.transaction.disable] - Disables running the write in a transaction mode. Defaults to `false`
     * @param {number} [options.transaction.maxPerChunk] - Max number of items to send in a single transaction chunk. Defaults to `1`
     * @param {number} [options.transaction.maxParallelRequests] - Max requests to issue in parallel. Defaults to `10`
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    write(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = {}) {
            var _a, e_1, _b, _c, _d, e_2, _e, _f;
            const { transaction = {}, headers = {} } = options;
            const { maxPerChunk = 1, // 1 has to be the default otherwise the chunks will be sent in transactions
            maxParallelRequests = DEFAULT_MAX_METHOD_PARALLEL_REQS, } = transaction;
            const { writes, deletes } = body;
            const authorizationModelId = this.getAuthorizationModelId(options);
            if (!(transaction === null || transaction === void 0 ? void 0 : transaction.disable)) {
                const apiBody = {
                    authorization_model_id: authorizationModelId,
                };
                if (writes === null || writes === void 0 ? void 0 : writes.length) {
                    apiBody.writes = { tuple_keys: writes };
                }
                if (deletes === null || deletes === void 0 ? void 0 : deletes.length) {
                    apiBody.deletes = { tuple_keys: deletes };
                }
                yield this.api.write(apiBody, options);
                return {
                    writes: (writes === null || writes === void 0 ? void 0 : writes.map(tuple => ({
                        tuple_key: tuple,
                        status: ClientWriteStatus.SUCCESS,
                    }))) || [],
                    deletes: (deletes === null || deletes === void 0 ? void 0 : deletes.map(tuple => ({
                        tuple_key: tuple,
                        status: ClientWriteStatus.SUCCESS,
                    }))) || []
                };
            }
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_METHOD_HEADER, "Write");
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_BULK_REQUEST_ID_HEADER, (0, utils_1.generateRandomIdWithNonUniqueFallback)());
            const writeResponses = [];
            if (writes === null || writes === void 0 ? void 0 : writes.length) {
                try {
                    for (var _g = true, _h = __asyncValues(asyncPool(maxParallelRequests, (0, utils_1.chunkArray)(writes, maxPerChunk), (chunk) => this.writeTuples(chunk, Object.assign(Object.assign({}, options), { headers, transaction: undefined })).catch(err => {
                        if (err instanceof errors_1.FgaApiAuthenticationError) {
                            throw err;
                        }
                        return {
                            writes: chunk.map(tuple => ({
                                tuple_key: tuple,
                                status: ClientWriteStatus.FAILURE,
                                err,
                            })),
                            deletes: []
                        };
                    }))), _j; _j = yield _h.next(), _a = _j.done, !_a; _g = true) {
                        _c = _j.value;
                        _g = false;
                        const singleChunkResponse = _c;
                        writeResponses.push(singleChunkResponse.writes);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_g && !_a && (_b = _h.return)) yield _b.call(_h);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            const deleteResponses = [];
            if (deletes === null || deletes === void 0 ? void 0 : deletes.length) {
                try {
                    for (var _k = true, _l = __asyncValues(asyncPool(maxParallelRequests, (0, utils_1.chunkArray)(deletes, maxPerChunk), (chunk) => this.deleteTuples(chunk, Object.assign(Object.assign({}, options), { headers, transaction: undefined })).catch(err => {
                        if (err instanceof errors_1.FgaApiAuthenticationError) {
                            throw err;
                        }
                        return {
                            writes: [],
                            deletes: chunk.map(tuple => ({
                                tuple_key: tuple,
                                status: ClientWriteStatus.FAILURE,
                                err,
                            })),
                        };
                    }))), _m; _m = yield _l.next(), _d = _m.done, !_d; _k = true) {
                        _f = _m.value;
                        _k = false;
                        const singleChunkResponse = _f;
                        deleteResponses.push(singleChunkResponse.deletes);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (!_k && !_d && (_e = _l.return)) yield _e.call(_l);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            return { writes: writeResponses.flat(), deletes: deleteResponses.flat() };
        });
    }
    /**
     * WriteTuples - Utility method to write tuples, wraps Write
     * @param {TupleKey[]} tuples
     * @param {ClientRequestOptsWithAuthZModelId & ClientWriteRequestOpts} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.transaction]
     * @param {boolean} [options.transaction.disable] - Disables running the write in a transaction mode. Defaults to `false`
     * @param {number} [options.transaction.maxPerChunk] - Max number of items to send in a single transaction chunk. Defaults to `1`
     * @param {number} [options.transaction.maxParallelRequests] - Max requests to issue in parallel. Defaults to `10`
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    writeTuples(tuples_1) {
        return __awaiter(this, arguments, void 0, function* (tuples, options = {}) {
            const { headers = {} } = options;
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_METHOD_HEADER, "WriteTuples");
            return this.write({ writes: tuples }, Object.assign(Object.assign({}, options), { headers }));
        });
    }
    /**
     * DeleteTuples - Utility method to delete tuples, wraps Write
     * @param {TupleKeyWithoutCondition[]} tuples
     * @param {ClientRequestOptsWithAuthZModelId & ClientWriteRequestOpts} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.transaction]
     * @param {boolean} [options.transaction.disable] - Disables running the write in a transaction mode. Defaults to `false`
     * @param {number} [options.transaction.maxPerChunk] - Max number of items to send in a single transaction chunk. Defaults to `1`
     * @param {number} [options.transaction.maxParallelRequests] - Max requests to issue in parallel. Defaults to `10`
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    deleteTuples(tuples_1) {
        return __awaiter(this, arguments, void 0, function* (tuples, options = {}) {
            const { headers = {} } = options;
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_METHOD_HEADER, "DeleteTuples");
            return this.write({ deletes: tuples }, Object.assign(Object.assign({}, options), { headers }));
        });
    }
    /************************
     * Relationship Queries *
     ************************/
    /**
     * Check - Check if a user has a particular relation with an object (evaluates)
     * @param {ClientCheckRequest} body
     * @param {ClientRequestOptsWithAuthZModelId} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    check(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = {}) {
            return this.api.check({
                tuple_key: {
                    user: body.user,
                    relation: body.relation,
                    object: body.object,
                },
                context: body.context,
                contextual_tuples: { tuple_keys: body.contextualTuples || [] },
                authorization_model_id: this.getAuthorizationModelId(options)
            }, options);
        });
    }
    /**
     * BatchCheck - Run a set of checks (evaluates)
     * @param {ClientBatchCheckRequest} body
     * @param {ClientRequestOptsWithAuthZModelId & BatchCheckRequestOpts} [options]
     * @param {number} [options.maxParallelRequests] - Max number of requests to issue in parallel. Defaults to `10`
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    batchCheck(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = {}) {
            var _a, e_3, _b, _c;
            const { headers = {}, maxParallelRequests = DEFAULT_MAX_METHOD_PARALLEL_REQS } = options;
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_METHOD_HEADER, "BatchCheck");
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_BULK_REQUEST_ID_HEADER, (0, utils_1.generateRandomIdWithNonUniqueFallback)());
            const responses = [];
            try {
                for (var _d = true, _e = __asyncValues(asyncPool(maxParallelRequests, body, (tuple) => this.check(tuple, Object.assign(Object.assign({}, options), { headers }))
                    .then(response => {
                    response._request = tuple;
                    return response;
                })
                    .catch(err => {
                    if (err instanceof errors_1.FgaApiAuthenticationError) {
                        throw err;
                    }
                    return {
                        allowed: undefined,
                        error: err,
                        _request: tuple,
                    };
                }))), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const singleCheckResponse = _c;
                    responses.push(singleCheckResponse);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return { responses };
        });
    }
    /**
     * Expand - Expands the relationships in userset tree format (evaluates)
     * @param {ClientExpandRequest} body
     * @param {string} body.relation The relation
     * @param {string} body.object The object, must be of the form: `<type>:<id>`
     * @param {ClientRequestOptsWithAuthZModelId} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    expand(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = {}) {
            return this.api.expand({
                authorization_model_id: this.getAuthorizationModelId(options),
                tuple_key: body,
            }, options);
        });
    }
    /**
     * ListObjects - List the objects of a particular type that the user has a certain relation to (evaluates)
     * @param {ClientListObjectsRequest} body
     * @param {ClientRequestOptsWithAuthZModelId} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    listObjects(body_1) {
        return __awaiter(this, arguments, void 0, function* (body, options = {}) {
            return this.api.listObjects({
                authorization_model_id: this.getAuthorizationModelId(options),
                user: body.user,
                relation: body.relation,
                type: body.type,
                context: body.context,
                contextual_tuples: { tuple_keys: body.contextualTuples || [] },
            }, options);
        });
    }
    /**
     * ListRelations - List all the relations a user has with an object (evaluates)
     * @param {object} listRelationsRequest
     * @param {string} listRelationsRequest.user The user object, must be of the form: `<type>:<id>`
     * @param {string} listRelationsRequest.object The object, must be of the form: `<type>:<id>`
     * @param {string[]} listRelationsRequest.relations The list of relations to check
     * @param {TupleKey[]} listRelationsRequest.contextualTuples The contextual tuples to send
     * @param {object} listRelationsRequest.context The contextual tuples to send
     * @param options
     */
    listRelations(listRelationsRequest_1) {
        return __awaiter(this, arguments, void 0, function* (listRelationsRequest, options = {}) {
            const { user, object, relations, contextualTuples, context } = listRelationsRequest;
            const { headers = {}, maxParallelRequests = DEFAULT_MAX_METHOD_PARALLEL_REQS } = options;
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_METHOD_HEADER, "ListRelations");
            (0, utils_1.setHeaderIfNotSet)(headers, CLIENT_BULK_REQUEST_ID_HEADER, (0, utils_1.generateRandomIdWithNonUniqueFallback)());
            if (!(relations === null || relations === void 0 ? void 0 : relations.length)) {
                throw new errors_1.FgaValidationError("relations", "When calling listRelations, at least one relation must be passed in the relations field");
            }
            const batchCheckResults = yield this.batchCheck(relations.map(relation => ({
                user,
                relation,
                object,
                contextualTuples,
                context,
            })), Object.assign(Object.assign({}, options), { headers, maxParallelRequests }));
            const firstErrorResponse = batchCheckResults.responses.find(response => response.error);
            if (firstErrorResponse) {
                throw firstErrorResponse.error;
            }
            return { relations: batchCheckResults.responses.filter(result => result.allowed).map(result => result._request.relation) };
        });
    }
    /**************
     * Assertions *
     **************/
    /**
     * ReadAssertions - Read assertions for a particular authorization model
     * @param {ClientRequestOptsWithAuthZModelId} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    readAssertions() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            return this.api.readAssertions(this.getAuthorizationModelId(options), options);
        });
    }
    /**
     * WriteAssertions - Updates assertions for a particular authorization model
     * @param {ClientWriteAssertionsRequest} assertions
     * @param {ClientRequestOptsWithAuthZModelId} [options]
     * @param {string} [options.authorizationModelId] - Overrides the authorization model id in the configuration
     * @param {object} [options.headers] - Custom headers to send alongside the request
     * @param {object} [options.retryParams] - Override the retry parameters for this request
     * @param {number} [options.retryParams.maxRetry] - Override the max number of retries on each API request
     * @param {number} [options.retryParams.minWaitInMs] - Override the minimum wait before a retry is initiated
     */
    writeAssertions(assertions_1) {
        return __awaiter(this, arguments, void 0, function* (assertions, options = {}) {
            return this.api.writeAssertions(this.getAuthorizationModelId(options), {
                assertions: assertions.map(assertion => ({
                    tuple_key: {
                        user: assertion.user,
                        relation: assertion.relation,
                        object: assertion.object,
                    },
                    expectation: assertion.expectation,
                }))
            }, options);
        });
    }
}
exports.OpenFgaClient = OpenFgaClient;
